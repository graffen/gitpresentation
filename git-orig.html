<!doctype html>
<html lang="en">

	<head>
		<meta charset="utf-8">

    <title>Git - an introduction</title>

    <meta name="description" content="An introduction to git">
    <meta name="author" content="Jesper Hess Nielsen">

		<meta name="apple-mobile-web-app-capable" content="yes" />
		<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />

		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, minimal-ui">

		<link rel="stylesheet" href="css/reveal.css">
		<link rel="stylesheet" href="css/theme/black.css" id="theme">

		<!-- Code syntax highlighting -->
		<link rel="stylesheet" href="lib/css/zenburn.css">

		<!-- Printing and PDF exports -->
		<script>
			var link = document.createElement( 'link' );
			link.rel = 'stylesheet';
			link.type = 'text/css';
			link.href = window.location.search.match( /print-pdf/gi ) ? 'css/print/pdf.css' : 'css/print/paper.css';
			document.getElementsByTagName( 'head' )[0].appendChild( link );
		</script>

		<!--[if lt IE 9]>
		<script src="lib/js/html5shiv.js"></script>2
		<![endif]-->
	</head>

	<body>

		<div class="reveal">
    <title>Git - an introduction</title>

    <meta name="description" content="An introduction to git">
    <meta name="author" content="Jesper Hess Nielsen">

			<!-- Any section element inside of this container is displayed as a slide -->
			<div class="slides">
        <!-- Any section element inside of this container is displayed as a slide -->
        <div class="slides">
            <section>
                <img src="images/GitIntro/Git-Logo-White.png" />
                <h2> - An Introduction</h2>
            </section>

            <section>
                <h1>Agenda</h1>
                <p>
                    <ul>
                        <li class="fragment">What is git?</li>
                        <li class="fragment">Getting started</li>
                        <li class="fragment">Git basics</li>
                        <li class="fragment">Git branching</li>
                        <li class="fragment">Git workflows</li>
                        <li class="fragment">Git &amp; TFS</li>
                        <li class="fragment">Open Discussion</li>
                    </ul>
                </p>
            </section>
            <section>
                <h1>What is git?</h1>
                <p>Git is a <span style="color: red">free</span> and <span style="color: orange;">open source</span> distributed <span style="color: yellow;">version control system</span> designed to handle everything from <span style="color: yellow">small</span> to <span style="color: red">very large</span> projects with <span style="color: fuchsia">speed</span> and <span style="color: orangered">efficiency</span>.</p>
            </section>

            <section>
                <h1>Why git?</h1>
                <h2> - a bit of history</h2>
                <aside class="notes" data-markdown>
* Created by Linus Torvalds in 2005 to replace BitKeeper
* Goals were:
    * Speed
    * Simple design
    * Strong support for non-linear development
    * Fully distributed - no central server!
    * Ability to handle large projects like the Linux Kernel with thousands of developers all over the world efficiently
                </aside>
            </section>

            <section>
                <section>
                    <h1>Part 1</h1>
                    <h2>Getting Started</h2>
                </section>

                <section>
                    <h1>About Version Control</h1>
                </section>

                <section>
                    <h2>Local Version Control Systems</h2>
                    <p class="fragment">
                        <img src="images/GitIntro/local-vcs.png" width="50%" />
                    </p>
                    <aside class="notes" data-markdown>
* rcs (still found preinstalled on modern MACs etc.)
                    </aside>
                </section>
                <section>
                    <h2>Or just use folders...</h2>
                    <p class="fragment"><img src="images/GitIntro/local-vcs-folders.png" /></p>
                    <aside class="notes" data-markdown>
* Local directories (- timestamped if you're clever)
But what if we want to collaborate with other developers?
                    </aside>
                </section>
                <section>
                    <h2>Centralized Version Control Systems</h2>
                    <p class="fragment roll-in">
                        <img src="images/GitIntro/centralized-vcs.png" width="50%" />
                    </p>
                    <aside class="notes" data-markdown>
* Collaborate with other devs
* CVS, Perforce, SVN, TFS etc.
* Single server contains all versioned files
* Requires server connection to do basic things like
    * View history
    * Check out
    * Merge
* Single Point of Failure!
                    </aside>
                </section>

                <section>
                    <h2>Distributed Version Control Systems</h2>
                    <p class="fragment roll-in">
                        <img src="images/GitIntro/distributed-vcs.png" width="40%" />
                    </p>
                    <aside class="notes" data-markdown>
* Git, Mercurial, Bazaar, Darcs
* Clients get full mirror of repo
* Every checkout essentially a full backup of all data
* Allow you to connect to remote repos & push and pull from there
* Set up complex workflows such as heirarchical models that centralized VCSs don't allow
                    </aside>
                </section>
            </section>
            <section>
                <section>
                    <h1>Git Basics</h1>
                </section>

                <section>
                    <h2>Start by <span style="color: orange">clearing</span> your <span style="color: greenyellow">mind</span>!</h2>
                    <aside class="notes" data-markdown>
* Clear your mind of things you know from SVN, TFS, Perforce.
* Doing so will help you avoid confusion
* Git stores and thinks about information much differently than these systems.

I'll stop using crazy colors now.
                    </aside>
                </section>

                <section>
                    <h2>Snapshots. Not Differences.</h2>
                    <aside class="notes" data-markdown>
* This is a key difference between git and other VCSs.
                    </aside>
                </section>

                <section>
                    <h2>Other systems store data as deltas to a base version of each file.</h2>
                    <p class="fragment">
                        <img src="images/GitIntro/checkins-deltas.png" width="80%" />
                    </p>
                    <aside class="notes" data-markdown>
The major difference between Git and any other VCS (Subversion and friends included) is the way Git thinks about its data. Conceptually, most other systems store information as a list of file-based changes. These systems (CVS, Subversion, Perforce, Bazaar, and so on) think of the information they keep as a set of files and the changes made to each file over time.
                    </aside>
                </section>

                <section>
                    <h2>Git stores data as snapshots of the project over time</h2>
                    <p class="fragment">
                        <img src="images/GitIntro/checkins-snapshots.png" width="80%" />
                    </p>
                    <aside class="notes" data-markdown>
* Git thinks of its data more like a set of snapshots of a mini-filesystem
* Git looks for changes when you commit, takes a picture of what files look like and stores a reference to that snapshot.
* To be efficient, if files have not changed, git doesn't store the file again. Just a link to the previous identical file it has already stored. 
                    </aside>
                </section>

                <section>
                    <h2>Nearly every operation is local</h2>
                    <aside class="notes" data-markdown>
* You don't need to communicate with the server to do things like: 
    * Browse history
    * View changes on a file between now and a month ago
* This makes git feel extremely fast. There's no network latency for doing stuff.
* You can now work - and commit code - while waiting for the bus or sitting on a plane
                    </aside>
                </section>

                <section>
                    <h2>Git has integrity</h2>
                    <ul class="fragment">
                        <li>Everything is checksummed before storage</li>
                        <li class="fragment">
                            Git uses SHA-1 hashes to perform the checksum
                            <pre><code data-trim class="no-highlight">24b9da6552252987aa493b52f8696cd6d3b00373</code></pre>
                        </li>
                        <li class="fragment">
                            SHA-1's are used to reference every object in git
                            <pre>
<code data-trim class="no-highlight">
> git log
commit 82bc0d42140bd857bcee94380d35ba680ac357f3
Author: Jesper Hess Nielsen &lt;jesper@graffen.dk&gt;
Date:   Tue Apr 1 08:49:33 2014 +0200
    Added two missing SIM WebConnect servers</code></pre>
                        </li>
                    </ul>
                    <aside class="notes" data-markdown>
* Get used to these fingerprints, you'll be referring to them a lot!
* SHA-1's are universal public identifiers. Collisions are extremely unlikely. 
* Every object in git has a SHA1 to identify it.
* Will get back to what objects are a bit later
                    </aside>
                </section>

                <section>
                    <h2>Git generally only adds data</h2>
                    <aside class="notes" data-markdown>
* Actions almost always add data to the git database
* It is very difficult to get the system to do anything that is not undoable or make it erase data in any way
* You can mess up before you commit. But once it's in there you can almost always get it back.
                    </aside>
                </section>

                <section>
                    <h2>Git is extremely effective on storage</h2>
                    <aside class="notes" data-markdown>
Example:
A fresh git repo containing WT 2.127 is 140 MB.
The checked out working directory is 593 MB.

Another example:
The current Linux kernel repository, including the entire history, is half the size of the current checkout.
                    </aside>
                </section>

                <section>
                    <h2>The three states</h2>
                    <p>
                        <ul>
                            <li class="fragment">modified</li>
                            <li class="fragment">staged</li>
                            <li class="fragment">committed</li>
                        </ul>
                    </p>
                    <aside class="notes" data-markdown>
* Modified means that you have changed the file but have not committed it to your database yet.
* Staged means that you have marked a modified file in its current version to go into your next commit snapshot.
* Committed means that the data is safely stored in your local database.
                    </aside>
                </section>

                <section>
                    <h2>The three main parts of a git repo</h2>
                    <p>
                        <ul>
                            <li class="fragment">The git directory</li>
                            <li class="fragment">The working directory</li>
                            <li class="fragment">The staging area or index</li>
                        </ul>
                    </p>
                    <aside class="notes" data-markdown>
* The git directory is where git stores the metadata and object database for your project. This is the most important part of Git
* The working directory is a single checkout of one version of the project. These files are pulled out of the compressed database in the Git directory and placed on disk for you to use or modify.
* The staging area is a simple file, generally contained in your git directory, that stores information about what will go into your next commit. Sometimes referred to as the index, but it’s becoming standard to refer to it as the staging area.
                    </aside>
                </section>

                <section>
                    <h2>The basic git workflow</h2>
                    <p class="fragment"><img src="images/GitIntro/localoperations.png" width="80%"/></p>
                    <aside class="notes" data-markdown>
* You modify files in your working directory.
* You stage the files, adding snapshots of them to your staging area.
* You do a commit, which takes the files as they are in the staging area and stores that snapshot permanently to your Git directory.
If a particular version of a file is in the git directory, it’s considered committed. If it’s modified but has been added to the staging area, it is staged. And if it was changed since it was checked out but has not been staged, it is modified.
                    </aside>
                </section>

                <section>
                    <h2>Getting Started</h2>
                    <h3>Installing Git</h3>
                </section>

                <section>
                    <h3>The easiest way to get git on Windows</h3>
                    <p><img src="images/GitIntro/githubdownload.png" width="80%" /></p>
                </section>

                <section>
                    <h3>Or just grab the official installer</h3>
                    <p><img src="/images/GitIntro/download_git_official.png" alt="" width="80%" /></p>
                </section>

                <section>
                    <h3>Initial configuration</h3>
                    <p>
                        <img src="images/GitIntro/githubinitialconfig.png" width="80%" />
                    </p>
                    <aside class="notes">Use Powershell because it's cool!</aside>
                </section>

                <section>
                    <h2>Use the console, Luke!</h2>
                    <div class="fragment">
                        <h3>Your identity</h3>
                        <pre><code data-trim class="no-highlight">
> git config --global user.name "Jesper Hess Nielsen"
> git config --global user.email "jesper@graffen.dk"
                        </code></pre>
                    </div>
                </section>

                <section>
                    <h2>Checking your settings</h2>
                    <pre><code class="no-highlight" data-trim>
> git config --list
user.name=Jesper Hess Nielsen
user.email=jesper@graffen.dk
color.status=auto
color.branch=auto
color.interactive=auto
...</code></pre>
                    <aside class="notes" data-markdown>
You may see some keys more than once. This is because git reads config from several places (global, then user-local). Git uses the <em>last</em> occurrence to decide what to do.
                    </aside>
                </section>

                <section>
                    <h2>What's my user.name?</h2>
                    <pre><code data-trim class="no-highlight">
> git config user.name
Jesper Hess Nielsen
</code></pre>
                </section>

                <section>
                    <h2>You can always get help</h2>
                    <pre><code data-trim class="no-highlight">
> git help &lt;verb&gt;
> git &lt;verb&gt; --help
</code></pre>
                    For example, get help for the config command:
                    <pre><code data-trim class="no-highlight">> git help config</code></pre>
                    <aside class="notes">
The git command line is generally very helpful and verbose.
                    </aside>
                </section>
            </section>

            <section>
                <section>
                    <h1>Part 2</h1>
                    <h2>Git Basics</h2>
                </section>
                <section>
                    <h2>Initializing a git repository</h2>
                    <pre><code data-trim class="no-highlight">
> git init
Initialized empty Git repository in D:/GitDemos/MyProject/.git/
</code></pre>
                    <p class="fragment">That's all there is to it.</p>
                </section>
                <section>
                    <h2>Cloning a Repository</h2>
                    <p>
                        <pre><code data-trim class="no-highlight">
> git clone https://github.com/madskristensen/MiniBlog
> git clone https://github.com/madskristensen/MiniBlog MyBlog
</code></pre>
                    </p>
                    <p class="fragment">
                        <img src="images/GitIntro/dolly-sheep.jpg" /><br />
                        Nope, not like the sheep.
                    </p>
                    <aside class="notes">
                        (demo) Clone from TFS git url to local machine
                    </aside>
                </section>
                <section>
                    <h2>This is how it looks</h2>
                    <p>
                        <pre><code data-trim class="no-highlight">
> git clone https://github.com/madskristensen/MiniBlog
Cloning into 'MiniBlog'...
remote: Reusing existing pack: 2428, done.
remote: Total 2428 (delta 0), reused 0 (delta 0)
Receiving objects: 100% (2428/2428), 8.03 MiB | 14.49 MiB/s, done.
Resolving deltas: 100% (1270/1270), done.
Checking connectivity... done
</code></pre>
                    </p>
                </section>
                <section>
                    <h2>Protocol support</h2>
                    <p>
                        <ul>
                            <li>Local filesystem</li>
                            <li>SMB (\\servername\share\repository)</li>
                            <li>HTTP(s)</li>
                            <li>SSH</li>
                            <li>git://</li>
                        </ul>
                    </p>
                </section>
                <section>
                    <h2>Working with the repo</h2>
                    <aside class="notes">
We now have our repo cloned and a checkout or working copy of the files. <br />
                    </aside>
                </section>

                <section>
                    <h2>Files can exist in one of several states</h2>
                    <img src="images/GitIntro/filestatuslifetime.png" width="80%" />
                    <aside class="notes" data-markdown>
Remember the three states from earlier?

* modified
* staged
* committed
                    </aside>
                </section>
                <section>
                    <h2>Checking the status of your files</h2>
                    <p>
                        <pre><code data-trim class="no-highlight">
> git status
# On branch master
nothing to commit, working directory clean</code></pre>
                    </p>
                </section>
                <section>
                    <h2>Tracking new files</h2>
                    <p>
                        <pre class="fragment"><code data-trim class="no-highlight">
> git status
# On branch master
# Untracked files:
#   (use "git add &lt;file&gt;..." to include in what will be committed)
#
#       howto.txt
nothing added to commit but untracked files present (use "git add" to track)
</code></pre>
                    </p>
                    <p>
                        <pre class="fragment"><code data-trim class="no-highlight">
> git add howto.txt
> git status
# On branch master
# Changes to be committed:
#   (use "git reset HEAD &lt;file&gt;..." to unstage)
#
#       new file:   howto.txt
</code></pre>
                    </p>
                    <aside class="notes" data-markdown>
First we add a new file in the working directory.
Then run git status to see that git has seen the file but hasn't been told to do anything about it just yet.

Run _git add_

We can now go ahead and commit that file to the repository.
                    </aside>
                </section>
                <section>
                    <h2>Staging modified files</h2>
                    <p>
                        <pre class="fragment"><code data-trim class="no-highlight">
> git status
# On branch master
# Changes to be committed:
#   (use "git reset HEAD &lt;file&gt;..." to unstage)
#
#       new file:   howto.txt
#
# Changes not staged for commit:
#   (use "git add &lt;file>..." to update what will be committed)
#   (use "git checkout -- &lt;file>..." to discard changes in working directory)
#
#       modified:   README.md
#
</code></pre>
                    </p>
                    <p>
                        <pre class="fragment"><code data-trim class="no-highlight">
> git add README.md
> git status
# On branch master
# Changes to be committed:
#   (use "git reset HEAD &lt;file&gt;..." to unstage)
#
#       modified:   README.md
#       new file:   howto.txt
#
</code></pre>
                    </p>
                    <aside class="notes" data-markdown>
Let's change a file that was already tracked<br />
Add the word "awesome" to README.md &amp; run git status again.

Then run _git add_ & _git status_ again.
                    </aside>
                </section>
                <section>
                    <h3>More staging</h3>
                    <p>
                        <pre class="fragment"><code data-trim class="no-highlight">
> notepad howto.txt
> git status
# On branch master
# Changes to be committed:
#   (use "git reset HEAD &gt;file>..." to unstage)
#
#       modified:   README.md
#       new file:   howto.txt
#
# Changes not staged for commit:
#   (use "git add &gt;file>..." to update what will be committed)
#   (use "git checkout -- &gt;file>..." to discard changes in working directory)
#
#       modified:   howto.txt
#
</code></pre>
                    </p>
                    <p class="fragment">What? Now <em>howto.txt</em> is both staged and unstaged?</p>

                    <aside class="notes" data-markdown>
What if we change a file that's already staged?

The staging area is the key here. We need to re-add the modified file to the staging area.
If we commit now, git will commit exactly as howto.txt looked when we staged it with _git add_.

We must run _git add_ again to stage the latest version of the file.
                    </aside>
                </section>
                <section>
                    <h2>Our snapshot is ready</h2>
                    <p>
                        <pre class="fragment"><code data-trim class="no-highlight">
> git add howto.txt
> git status
# On branch master
# Changes to be committed:
#   (use "git reset HEAD &lt;file>..." to unstage)
#
#       modified:   README.md
#       new file:   howto.txt
#
</code></pre>
                    </p>
                    <p class="fragment">So let's commit our changes.</p>
                    <p>
                        <pre class="fragment"><code data-trim class="no-highlight">
> git commit -m"Reworded the headline in README.md and added howto.txt"
[master 39f41db] Reworded the headline in README.md and added howto.txt
 2 files changed, 2 insertions(+), 1 deletion(-)
 create mode 100644 howto.txt
</code></pre>
                    </p>
                    <aside class="notes">
                        <ul>
                            <li>Run git add on our modified file to add it to the snapshot</li>
                            <li>Run git commit</li>
                            <li>Git requires you to enter commit messages when committing code.</li>
                        </ul>
                    </aside>
                </section>
                <section>
                    <h2>Reviewing our history</h2>
                    <p>
                        <pre class="fragment"><code data-trim class="no-highlight">
> git log
commit 39f41db15e8a567a545653423dd97c857addcfca
Author: Jesper Hess Nielsen &lt;jesper@graffen.dk>
Date:   Fri May 2 14:06:32 2014 +0200
    Reworded the headline in README.md and added howto.txt
commit 824d7876f0c5b792220d1ae33b0dff2486b79283
Author: Mads Kristensen &lt;post@madskristensen.net>
Date:   Fri Apr 25 08:29:42 2014 -0700
    Redirect to login page from email links
...
...
</code></pre>
                    </p>
                    <aside class="notes">
                        Once things are committed we can go back and view the commit history.<br />
                        Notice how every commit is referenced by a SHA-1 hash. <br />
                        Mention gitk (or show in demo)
                    </aside>
                </section>
            </section>

            <section>
                <section>
                    <h1>Part 3</h1>
                    <h2>Git Branching</h2>
                    <aside class="notes" data-markdown>
This is going to be an extremely brief introduction to what branches are in git terminology.
                    </aside>
                </section>
                <section>
                    <h2>What is a branch?</h2>
                    <p class="reveal">
                        Nothing more than a 40-character text file inside your repository.
                    </p>
                </section>
                <section>
                    <h2>How does branching in git work?</h2>
                    <p class="fragment">
                     - by moving that pointer around.
                    </p>
                    <aside class="notes" data-markdown>
Let's take a look at this really simple concept.                    
                    </aside>
                </section>
                <section>
                    <h2>What is a commit really?</h2>
                    <p class="fragment">
                        <img src="/images/GitIntro/commit_conceptual_view.png" alt="" width="80%" />
                    </p>
                    <aside class="notes" data-markdown>
* Remember that git stores data as a series of snapshots, NOT a series of deltas
* On commit, git stores a commit object that contains a pointer to the snapshot of the content you staged
* Contains zero or more pointers to the commit or commits that were the direct parents of the commit.
* We create a repo with three files and commit them. Your git repo now contains five objects:
* One blob for the contents of each of your three files
* One tree that lists the contents of the directory and specifies filenames -> blob relationship
* One commit with the pointer to the root tree and all the commit metadata. [SHOW IMAGE NOW]
                    </aside>
                </section>
                <section>
                    <h2>Add more commits</h2>
                    <p class="fragment"><img src="/images/GitIntro/branches-commits-chain.png" alt="" width="80%" /></p>
                    <aside class="notes" data-markdown>
So we make some changes and add a few more commits.
Each commit adds a pointer to the commit before it. After two commits your commit chain looks something like this
                    </aside>
                </section>
                <section>
                    <h2>The master branch</h2>
                    <p>
                        <img src="/images/GitIntro/branches-master-1.png" alt="" width="80%" />
                    </p>
                    <aside class="notes" data-markdown>
A branch in git is simply a lightweight movable pointer to one of these commits. The default branch name in Git is master. As you initially make commits, you’re given a master branch that points to the last commit you made. Every time you commit, it moves forward automatically.
                    </aside>
                </section>
                <section>
                    <h2>Create a new branch</h2>
                    <p>
                        <pre><code data-trim class="no-highlight">
> git branch testing
</code></pre>
                    </p>
                    <p class="fragment">
                        <img src="/images/GitIntro/branches-add-new-branch.png" alt="" width="80%" />
                    </p>
                    <aside class="notes" data-markdown>
Adding a new branch simply creates a new pointer on the same commit you're currently on.
                    </aside>
                </section>
                <section>
                    <h2>The HEAD pointer</h2>
                    <p class="fragment">
                        <img src="/images/GitIntro/branches-head.png" alt="" width="80%" />
                    </p>
                    <aside class="notes" data-markdown>
How does git know which branch you're on?
HEAD is simply a pointer to your current branch and is how git keeps track of where you are.
In this case you're still on master. git branch only creates a new branch. It didn't switch to that branch.
                    </aside>
                </section>
                <section>
                    <h2>Switching branches</h2>
                    <p>
                        <pre><code data-trim class="no-highlight">
> git checkout testing
</code></pre>
                    </p>
                    <p class="fragment">
                        <img src="/images/GitIntro/branches-head-testing.png" alt="" width="80%" />
                    </p>
                    <aside class="notes" data-markdown>
This simply moves HEAD to point to the testing branch.
                    </aside>
                </section>
                <section>
                    <h2>Let's add a commit</h2>
                    <p>
                        <pre><code data-trim class="no-highlight">
> notepad test.rb
> git commit -a -m "made a change"
</code></pre>
                    </p>
                    <p class="fragment">
                        <img src="/images/GitIntro/branches-testing-commit.png" alt="" width="80%" />
                    </p>
                    <aside class="notes" data-markdown>
This is interesting because testing has moved forward but master still points to the previous commit.
Let's swich back to the master branch (next slide)
                    </aside>
                </section>
                <section>
                    <h2>Switch back to master</h2>
                    <p>
                        <pre><code class="no-highlight" data-trim>
> git checkout master
</code></pre>
                    </p>
                    <p class="fragment">
                        <img src="/images/GitIntro/branches-back-to-master.png" alt="" width="80%" />
                    </p>
                    <aside class="notes" data-markdown>
Two things just happened:

* The HEAD pointer was moved back to point to the master branch
* Files in the working dir were reverted back to the snapshot that master points to.

Changes made from this point will diverge from an older version of the project.
Let's make a few more changes and commit again.
                    </aside>
                </section>
                <section>
                    <h2>A few more changes</h2>
                    <p>
                        <pre><code data-trim class="no-highlight">
> notepad test.rb
> git commit -am "Made another change"
</code></pre>
                    </p>
                    <p class="fragment">
                        <img src="/images/GitIntro/branches-master-morecommits.png" alt="" width="80%" />
                    </p>
                    <aside class="notes" data-markdown>
* Project has now diverged
* Both changes are isolated in separate branches.
* All this is done with simple branch and checkout commands.
* A git branch is simply a 40-character text file. (41 bytes including newline - REALLY fast to create)

* Other VCS's typically copy all files to second directory. This takes TIME!
* Easy to find merge base since parents are recorded in history.
                    </aside>
                </section>
                <section>
                    <h2>All this happens on your local machine!</h2>
                    <p class="fragment">
                        Branches only appear on the server if you explicitly push them there. 
                    </p>
                    <aside class="notes" data-markdown>
I could have dozens or even hundreds of branches in my repo without anyone ever knowing about them. 
It's only if I explicitly choose to push my branches upstream that they become available to others. 
  
Note that branches all live _inside_ the repo. You won't see thousands of clones of the codebase on the server.
                    </aside>
                </section>                
                <section>
                    <h2>Advanced topics for another time</h2>
                    <p>
                        <ul>
                            <li>Merging and branching strategies</li>
                            <li>Rebasing & rewriting history</li>
                            <li>git bisect</li>
                            <li>Interactive commits & cherry picking</li>
                            <li>The reflog</li>
                        </ul>
                    </p>
                    <aside class="notes" data-markdown>
* Because of time constraints we won't go through these now
* Merging in Git is less painful because Git keeps track of the common merge-base through tracking ancestors.
* Rebase allows us to keep our history neat and tidy by minimizing "merge commits"
* git bisect helps to find the exact commit when a bug was introduced
* Interactive commits allow us to build very neat history timelines
* The reflog is the git repos own version control. It can help us if we screw up badly.
                    </aside>
                </section>
            </section>
            <section>
                <section>
                    <h1>Part 4</h1>
                    <h2>Git workflows</h2>
                </section>
                <section>
                    <h2>Centralized Workflow</h2>
                    <img src="/images/GitIntro/workflow_centralized.png" alt="" width="80%" />
                    <aside class="notes" data-markdown>
* Essentially the same model as with any CVCS like TFVC or SVN
* First-to-push wins. Following have to merge.
* Still have the benifit of working locally!
                    </aside>
                </section>

                <section>
                    <h2>Integration-Manager Workflow</h2>
                    <img src="/images/GitIntro/workflow_integrationmanager.png" alt="" width="80%" />
                    <aside class="notes">
                        This is basically how the Pull Request workflow in GitHub works.
                        <ol>
                            <li>The project maintainer pushes to their public repository.</li>
                            <li>A contributor clones that repository and makes changes.</li>
                            <li>The contributor pushes to their own public copy or "fork"</li>
                            <li>The contributor sends the maintainer an e-mail asking them to pull changes
                            (or presses the Pull Request button)</li>
                            <li>The maintainer adds the contributor’s repo as a remote and merges locally.
                            (Or does the merge through Github)</li>
                            <li>The maintainer pushes merged changes to the main repository.
                            (Or lets Github do the magic)</li>
                        </ol>
                    </aside>
                </section>

                <section>
                    <h2>Dictator and Lieutenants Workflow</h2>
                    <img src="/images/GitIntro/workflow_dictatorAndLieutenants.png" alt="" width="80%" />
                    <aside class="notes">
                        This is a variant of a multiple-repository workflow. It’s generally used by huge projects with hundreds of collaborators; one famous example is the Linux kernel.
                        <ol>
                            <li>Regular developers work on their topic branch and rebase their work on top of master. The master branch is that of the dictator.</li>
                            <li>Lieutenants merge the developers’ topic branches into their master branch.</li>
                            <li>The dictator merges the lieutenants’ master branches into the dictator’s master branch.</li>
                            <li>The dictator pushes their master to the reference repository so the other developers can rebase on it.</li>
                        </ol>
                    </aside>
                </section>

            </section>

            <section>
                <section>
                    <h1>Part 5</h1>
                    <h2>Git in VS & TFS</h2>
                </section>

                <section>
                    <h2>Tooling Support</h2>
                    <ul>
                        <li>VS has supported git natively since VS 2012 update 2</li>
                        <li>TFS supports git repos on the server since TFS 2013</li>
                        <li>TFS 2013 update 4 includes <em>rudimentary</em> pull-request support</li>
                    </ul>
                    <aside class="notes" data-markdown>
You can connect your VS to local git repos and work from the Team Explorer to do most day-to-day stuff.
You can now host git repositories natively in TFS. No more "hacking" to get git & TFS to work

* This means no more use for git-tf & other funny ways of working. Unless you're stuck with the old TFS source control.
* Rumors have it that Microsoft is considering switching to git completely as the default TFS source control.
                    </aside>
                </section>

                <section>
                    <h2>TFVC vs Git VC</h2>
                    <aside class="notes" data-markdown>
* You need to look at the strengths and features of each VCS.
* Also take into account the experiences and preferences of team members
* Choice simply comes down to which VCS to use
* (because git is fully integrated in TFS)
                    </aside>
                </section>

                <section>
                    <h2>Team Foundation Server Version Control</h2>
                    <h3>(TFSVC)</h3>
                    <aside class="notes">
                        <ul>
                            <li>Centralized version control system</li>
                            <li>Works well for small codebases</li>
                            <li>Scalable for very large codebases (together with the server workspace)</li>
                            <li>Provides granular permission control</li>
                            <li>
                                <div>Because of the centralized character:</div>
                                <ul>
                                    <li>It is easy to audit changes</li>
                                    <li>It is easy to identify who changed the code/files</li>
                                </ul>
                            </li>
                        </ul>
                    </aside>
                </section>

                <section>
                    <h2>Git Version Control</h2>
                    <h3>(Git VC)</h3>
                    <aside class="notes">
                        <ul>
                            <li>Distributed version control system</li>
                            <li>Each developer has a copy of the entire source repository, on their local disk, implicating that developers can work, even when connectivity is an issue.</li>
                            <li>
                                <div>Branching is very lightweight:</div>
                                <ul>
                                    <li>Create local and private branches</li>
                                    <li>Context switching made easy</li>
                                    <li>Branch only available for all team members, after being pushed to the server.</li>
                                </ul>
                            </li>
                            <li>Local repository is version control enabled</li>
                            <li>You can have modular codebases distributed across multiple repositories</li>
                        </ul>
                    </aside>
                </section>

                <section>
                    <h2>Git commands explained</h2>
                    <table>
                        <thead>
                            <tr>
                                <th>
                                    Git VC
                                </th>
                                <th>
                                    Team Foundation VC
                                </th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td>
                                    Commit
                                </td>
                                <td>
                                    n/a
                                </td>
                            </tr>
                            <tr>
                                <td>
                                    Push
                                </td>
                                <td>
                                    Check-in
                                </td>
                            </tr>
                            <tr>
                                <td>
                                    Fetch
                                </td>
                                <td>
                                    Get-Latest
                                </td>
                            </tr>
                            <tr>
                                <td>
                                    Pull
                                </td>
                                <td>
                                    Get-Latest + Merge
                                </td>
                            </tr>
                        </tbody>
                    </table>
                    <aside class="notes" data-markdown>
* Commit has no real TFS equivalent
* Time to show how it works
                    </aside>
                </section>

                <section>
                    <h1>Summary</h1>
                </section>

                <section>
                    <h2>Git is a first-class citizen inside TFS</h2>
                    <aside class="notes" data-markdown>
* TFS team is working to make the git experience comparable to the one we know and "love" from TFS.
* My work etc.
* Pull request workflow (only web-based for now) is available in latest update 4 of TFS server.
                    </aside>
                </section>
                <section data-markdown>
                    <script type="text/template">
## Obstacles in the organsiation ##
- TFS is "controlled" by the ALM team <!-- .element: class="fragment" -->
- TFS is still the official SCM inside Saxo Bank. <!-- .element: class="fragment" -->
- This means we as developers can't simply create repos as needed <!-- .element: class="fragment" -->
	- Instead we need to ask to have them created. 
- There is a definite learning curve to take into account. It's a completely different beast to what most of us are used to. <!-- .element: class="fragment" -->
                    </script>
                </section>
            </section>
            <section>
                <h1>Discussion time!</h1>
            </section>
            <!--<section>
                <h1>Contact info</h1>
                <p>
                    Twitter: @graffen<br />
                    Email: jesper@graffen.dk <br />
                    Jabber: graffen@graffen.dk
                </p>            
            </section>-->
            <section>
                <h1>THE END</h1>
            </section>

            <!--<section>
                <img src="images/GitIntro/not-sure-if-presentation-is-over-or-its-time-for-the-demo.jpg" />
                <aside class="notes">
                    <ol>
                        <li>Initialize git repo, show .git subdirectory</li>
                        <li>Add new text file, add some content</li>
                        <li>Mention difference between tracked and untracked files</li>
                        <li>Stage file (git add filename), show status</li>
                        <li>Commit</li>
                        <li>Edit file again, show status</li>
                        <li>Stage, commit</li>
                        <li>Show log</li>
                    </ol>
                </aside>
            </section>-->
        </div>

		</div>

		<script src="lib/js/head.min.js"></script>
		<script src="js/reveal.js"></script>

		<script>

			// Full list of configuration options available at:
			// https://github.com/hakimel/reveal.js#configuration
			Reveal.initialize({
				controls: true,
				progress: true,
				history: true,
				center: true,

				transition: 'slide', // none/fade/slide/convex/concave/zoom

                multiplex: {
                    secret: '14790332233547146315',
                    id: '9e2066bdbfc85901',
                    url: 'https://socketio.azurewebsites.net'
                },
				// Optional reveal.js plugins
				dependencies: [
	                { src: 'socket.io/socket.io.js', async: true },
                    { src: '//cdn.socket.io/socket.io-1.3.5.js', async: true },
                    { src: ' plugin/multiplex/master.js', async: true },
    	            { src: 'plugin/notes-server/client.js', async: true },
					{ src: 'lib/js/classList.js', condition: function() { return !document.body.classList; } },
					{ src: 'plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
					{ src: 'plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
					{ src: 'plugin/highlight/highlight.js', async: true, condition: function() { return !!document.querySelector( 'pre code' ); }, callback: function() { hljs.initHighlightingOnLoad(); } },
					{ src: 'plugin/zoom-js/zoom.js', async: true },
					{ src: 'plugin/notes/notes.js', async: true }
				]
			});

		</script>

	</body>
</html>
