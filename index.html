<!doctype html>
<html lang="en">

	<head>
		<meta charset="utf-8">

    <title>Git - an introduction</title>

    <meta name="description" content="An introduction to git">
    <meta name="author" content="Jesper Hess Nielsen">

		<meta name="apple-mobile-web-app-capable" content="yes" />
		<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />

		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, minimal-ui">

		<link rel="stylesheet" href="css/reveal.css">
		<link rel="stylesheet" href="css/theme/black.css" id="theme">

		<!-- Code syntax highlighting -->
		<link rel="stylesheet" href="lib/css/zenburn.css">

		<!-- Printing and PDF exports -->
		<script>
			var link = document.createElement( 'link' );
			link.rel = 'stylesheet';
			link.type = 'text/css';
			link.href = window.location.search.match( /print-pdf/gi ) ? 'css/print/pdf.css' : 'css/print/paper.css';
			document.getElementsByTagName( 'head' )[0].appendChild( link );
		</script>

		<!--[if lt IE 9]>
		<script src="lib/js/html5shiv.js"></script>2
		<![endif]-->
	</head>

	<body>
		<div class="reveal">
			<!-- Any section element inside of this container is displayed as a slide -->
           <div class="slides">
            <section>
                <img src="images/GitIntro/Git-Logo-White.png" />
                <h2> - An Introduction</h2>
            </section>

            <section>
                <h1>Agenda</h1>
                <p>
                    <ul>
                        <li class="fragment">What is git?</li>
                        <li class="fragment">Getting started</li>
                        <li class="fragment">Git basics</li>
                        <li class="fragment">Git branching, merging & rebasing</li>
                        <li class="fragment">Git workflows</li>
                        <li class="fragment">Demo/Hands-on <br /><small>(we probably won't have time for this today)</small></li>
                    </ul>
                </p>
            </section>
            <section>
                <h1>What is git?</h1>
                <p>Git is a <span style="color: red">free</span> and <span style="color: orange;">open source</span> <b>distributed</b> <span style="color: yellow;">version control system</span> designed to handle everything from <span style="color: yellow">small</span> to <span style="color: red">very large</span> projects with <span style="color: fuchsia">speed</span> and <span style="color: orangered">efficiency</span>.</p>
            </section>
            <section>
                <h1>Why git?</h1>
                <aside class="notes" data-markdown>
* Created by Linus Torvalds in 2005 to replace BitKeeper
* Goals were:
    * Speed
    * Simple design
    * Strong support for non-linear development
    * Fully distributed - no central server!
    * Ability to handle large projects like the Linux Kernel with thousands of developers all over the world efficiently
                </aside>
            </section>
            <section>
                <p><q>&ldquo;I'm egotistical, and I name all my projects after myself. First Linux, now git&rdquo;</q> <br /><br /><em>- Linus Torvalds</em></p>
            </section>
            <section>
                <p>Git [ɡɪt]: British slang for &ldquo;pig-headed, they are always correct, argumentative&rdquo;
                <aside class="notes">Truth is, the real reason will probably go with Linus to his grave</aside>
            </section>
            <section>
                <section>
                    <h1>Part 1</h1>
                    <h2>Getting Started</h2>
                </section>

                <section>
                    <h1>VCS in general</h1>
                    <aside class="notes">
                        Just a quick recap, going back to basics
                    </aside>
                </section>
                <section>
                    <h2>Local Version Control Systems</h2>
                    <p>
                        <img src="images/GitIntro/local-vcs.png" width="50%" />
                        <h3 class="fragment">Can't talk to the network</h3>
                    </p>
                    <aside class="notes" data-markdown>
* rcs (still found preinstalled on modern Macs etc.)
* Cannot be used over the network
                    </aside>
                </section>
                <section data-transition="slide-in">
                    <h2>Or just use folders...</h2>
                    <p><img src="images/GitIntro/local-vcs-folders.png" /></p>
                    <aside class="notes" data-markdown>
* Local directories (- timestamped if you're clever)
* But what if we want to collaborate with other developers?
                    </aside>
                </section>
                <section>
                    <h2>Centralized Version Control Systems</h2>
                    <p>
                        <img src="images/GitIntro/centralized-vcs.png" width="50%" />
                        <h3 class="fragment">Require network access!</h3>
                    </p>
                    <aside class="notes" data-markdown>
* Collaborate with other devs
* CVS, Perforce, SVN, TFS etc.
* Single server contains all versioned files
* Requires server connection to do basic things like
    * View history
    * Check out
    * Merge
* Single Point of Failure!
                    </aside>
                </section>

                <section>
                    <h3>Distributed Version Control Systems</h3>
                    <p>
                        <img src="images/GitIntro/distributed-vcs.png" width="40%" />
                        <h3 class="fragment">Do not require network access</h3>
                    </p>
                    <aside class="notes" data-markdown>
* Git, Mercurial, Bazaar, Darcs
* Clients get full mirror of repo
* Every clone essentially a full backup of all data
* Allow you to connect to remote repos & push and pull from there
* Set up complex workflows such as heirarchical models that centralized VCSs don't allow
                    </aside>
                </section>
            </section>
            <section>
                <section>
                    <h1>Git Basics</h1>
                </section>

                <section>
                    <h2>Start by <span style="color: orange">clearing</span> your <span style="color: greenyellow">mind</span>!</h2>
                    <aside class="notes" data-markdown>
* Clear your mind of things you know from SVN, TFS, Perforce.
* Doing so will help you avoid confusion
* Git stores and thinks about information much differently than these systems.
                    </aside>
                </section>
                <section>
                    <h2>Other systems store data as deltas to a base version of each file.</h2>
                    <p class="fragment">
                        <img src="images/GitIntro/checkins-deltas.png" width="80%" />
                    </p>
                    <aside class="notes" data-markdown>
The major difference between Git and any other VCS (Subversion and friends included) is the way Git thinks about its data. Conceptually, most other systems store information as a list of file-based changes. These systems (CVS, Subversion, Perforce, Bazaar, and so on) think of the information they keep as a set of files and the changes made to each file over time.
                    </aside>
                </section>
                <section> 
                    <h2>Snapshots! Not Differences.</h2>
                    <p class="fragment">
                        <img src="images/GitIntro/checkins-snapshots.png" width="80%" />
                    </p>
                    <aside class="notes" data-markdown>
* Git thinks of its data more like a set of snapshots of a mini-filesystem
* Git looks for changes when you commit, takes a picture of what files look like and stores a reference to that snapshot.
* To be efficient, if files have not changed, git doesn't store the file again since everything is referred to by hash. 
                    </aside>
                </section>
                <section>
                    <h2>Nearly every operation is local</h2>
                    <aside class="notes" data-markdown>
* You don't need to communicate with the server to do things like: 
    * Browse history
    * View changes on a file between now and a month ago
* This makes git feel extremely fast. There's no network latency for doing stuff.
* You can now work - and commit code - while waiting for the bus or sitting on a plane
                    </aside>
                </section>

                <section>
                    <h2>Git has integrity</h2>
                    <ul class="fragment">
                        <li>Everything is checksummed before storage</li>
                        <li class="fragment">
                            Git uses SHA-1 hashes to perform the checksum
                            <pre><code class="hljs-bash">24b9da6552252987aa493b52f8696cd6d3b00373</code></pre>
                        </li>
                        <li class="fragment">
                            SHA-1's are used to reference every object in git
                            <pre>
<code data-trim class="hljs-bash">
> git log
commit 82bc0d42140bd857bcee94380d35ba680ac357f3
Author: Jesper Hess Nielsen &lt;jesper@graffen.dk&gt;
Date:   Tue Apr 1 08:49:33 2014 +0200
    Add two missing SIM WebConnect servers</code></pre>
                        </li>
                    </ul>
                    <aside class="notes" data-markdown>
* Get used to these fingerprints, you'll be referring to them a lot!
* SHA-1's are universal public identifiers. Collisions are extremely unlikely. 
* Every object in git has a SHA1 to identify it.
* Will get back to what objects are a bit later
                    </aside>
                </section>
                <section>
                <h2>Integrity is important!</h2>
                <p>It means we can trust Git 100% to deliver the correct bytes to us.</p>
                <aside class="notes">If I check out a commit hash on my PC and you check out the same commit hash on yours, we can be sure we're seeing the exact same data.</aside>
                </section>
                <section>
                    <h2>Git generally only adds data</h2>
                    <aside class="notes" data-markdown>
* Actions almost always add data to the git database
* It is very difficult to get the system to do anything that is not undoable or make it erase data in any way
* You can mess up before you commit. But once it's in there you can almost always get it back.
* Trust Git!
                    </aside>
                </section>

                <section>
                    <h2>Git is extremely effective on storage</h2>
                    <aside class="notes" data-markdown>
Example:
The current Linux kernel repository, including the entire history 10 years back is only three times the size of its current checked-out working directory. That's ~1.7GB for _every_ single change done to the
Linux source code, ~575.000 comits, by literally thousands of developers working pretty-much non-stop for 10 years. 
                    </aside>
                </section>
                <section>
                    <h2>The three main parts of a git repo</h2>
                    <p>
                        <ul>
                            <li class="fragment">The .git directory</li>
                            <li class="fragment">The working directory</li>
                            <li class="fragment">The staging area or index</li>
                        </ul>
                    </p>
                    <aside class="notes" data-markdown>
* The git directory is where git stores the metadata and object database for your project. This is the most important part of Git
* The working directory is a single checkout of one version of the project. These files are pulled out of the compressed database in the Git directory and placed on disk for you to use or modify.
* The staging area is a simple file, generally contained in your git directory, that stores information about what will go into your next commit. Sometimes referred to as the index, but it’s becoming standard to refer to it as the staging area.
                    </aside>
                </section>
                <section>
                    <h3>Files exist in one of three (four) states</h3>
                    <p>
                        <ul>
                            <li class="fragment">modified</li>
                            <li class="fragment">staged</li>
                            <li class="fragment">committed</li>
                            <li class="fragment">(untracked)</li>
                        </ul>
                    </p>
                    <aside class="notes" data-markdown>
* Modified means that you have changed the file but have not committed it to your database yet.
* Staged means that you have marked a modified file in its current version to go into your next commit snapshot.
* Committed means that the data is safely stored in your local database.
* A file can also be unknown to Git. That's called untacked.
* Try not to use the phrase "checked in". The Checkin concept doesn't exist in Git.
                    </aside>
                </section>
                <section>
                    <img src="images/GitIntro/filestatuslifetime.png" width="80%" />
                </section>

                <section>
                    <h2>A basic git workflow</h2>
                    <p class="fragment"><img src="images/GitIntro/localoperations.png" width="80%"/></p>
                    <aside class="notes" data-markdown>
* You modify files in your working directory.
* You stage the files, adding snapshots of them to your staging area.
* You do a commit, which takes the files as they are in the staging area and stores that snapshot permanently to your Git directory.
If a particular version of a file is in the git directory, it’s considered committed. If it’s modified but has been added to the staging area, it is staged. And if it was changed since it was checked out but has not been staged, it is modified.
                    </aside>
                </section>

                <section>
                    <h2>Getting Started</h2>
                    <h3>Installing Git</h3>
                </section>
                <section>
                    <h3>Just grab the official installer</h3>
                    <p><img src="/images/GitIntro/download_git_official.png" alt="" width="80%" /><br />
                    https://git-scm.com/</p>
                </section>
                <section>
                    <h2>Initial configuration</h2>
                    <div class="fragment">
                        <h3>Your identity</h3>
                        <pre><code data-trim class="bash">
> git config --global user.name "Jesper Hess Nielsen"
> git config --global user.email "jnc@saxobank.com"
                        </code></pre>
                    </div>
                    <aside class="notes">Force yourself to use the console instead of VS, until you understand what's going on.</aside>
                </section>

                <section>
                    <h2>Checking your settings</h2>
                    <pre><code class="bash" data-trim>
> git config --list
user.name=Jesper Hess Nielsen
user.email=jnc@saxobank.com
color.status=auto
color.branch=auto
color.interactive=auto
...</code></pre>
                    <aside class="notes" data-markdown>
You may see some keys more than once. This is because git reads config from several places (global, then user-local). Git uses the <em>last</em> occurrence to decide what to do.
                    </aside>
                </section>

                <section>
                    <h2>What's my user.name?</h2>
                    <pre><code data-trim class="bash">
> git config user.name
Jesper Hess Nielsen
</code></pre>
                </section>

                <section>
                    <h2>You can always get help</h2>
                    <pre><code data-trim class="bash">
> git help &lt;verb&gt;
> git &lt;verb&gt; --help
</code></pre>
                    For example, get help for the config command:
                    <pre><code data-trim class="bash">> git help config</code></pre>
                    <aside class="notes">
The git command line is generally very helpful and verbose.
                    </aside>
                </section>
            </section>
            <section>
                <section>
                    <h1>Part 2</h1>
                    <h2>Git Basics</h2>
                </section>
                <section>
                    <h2>Initializing a git repository</h2>
                    <pre><code data-trim class="bash">
> git init
Initialized empty Git repository in D:/GitDemos/MyProject/.git/
</code></pre>
                    <p class="fragment">That's all there is to it.</p>
                </section>
                <section>
                    <h2>Cloning a Repository</h2>
                    <p>
                        <pre><code data-trim class="bash">
> git clone https://github.com/madskristensen/MiniBlog
> git clone https://github.com/madskristensen/MiniBlog MyBlog
</code></pre>
                    </p>
                    <p class="fragment">
                        <img src="images/GitIntro/dolly-sheep.jpg" /><br />
                        Kind of like the sheep.
                    </p>
                    <aside class="notes">
                        (demo) Clone from TFS git url to local machine
                    </aside>
                </section>
                <section>
                    <h2>This is how it looks</h2>
                    <p>
                        <pre><code data-trim class="bash">
> git clone https://github.com/madskristensen/MiniBlog
Cloning into 'MiniBlog'...
remote: Reusing existing pack: 2428, done.
remote: Total 2428 (delta 0), reused 0 (delta 0)
Receiving objects: 100% (2428/2428), 8.03 MiB | 14.49 MiB/s, done.
Resolving deltas: 100% (1270/1270), done.
Checking connectivity... done
</code></pre>
                    </p>
                </section>
                <section>
                    <h2>Protocol support</h2>
                    <p>
                        <ul>
                            <li>Local filesystem (duh!)</li>
                            <li>SMB (\\servername\share\repository)</li>
                            <li>HTTP(s)</li>
                            <li>SSH</li>
                            <li>git://</li>
                        </ul>
                    </p>
                </section>
                <section>
                    <h1>Demo</h1>
                </section>
            </section>
            <section>
                <section>
                    <h1>Part 3</h1>
                    <h2>Git Branching</h2>
                    <aside class="notes" data-markdown>
This is going to be an extremely brief introduction to what branches are in git terminology.
                    </aside>
                </section>
                <section>
                    <h2>What is a branch?</h2>
                    <p class="reveal">
                        Nothing more than a 40-character text file inside your repository.
                    </p>
                </section>
                <section>
                    <h2>How does branching in git work?</h2>
                    <p class="fragment">
                     - by moving that pointer around.
                    </p>
                    <aside class="notes" data-markdown>
Let's take a look at this really simple concept.                    
                    </aside>
                </section>
                <section>
                    <h2>What is a commit really?</h2>
                    <p class="fragment">
                        <img src="/images/GitIntro/commit_conceptual_view.png" alt="" width="80%" />
                    </p>
                    <aside class="notes" data-markdown>
* Remember that git stores data as a series of snapshots, NOT a series of deltas
* On commit, git stores a commit object that contains a pointer to the snapshot of the content you staged
* Contains zero or more pointers to the commit or commits that were the direct parents of the commit.
* We create a repo with three files and commit them. Your git repo now contains five objects:
* One blob for the contents of each of your three files
* One tree that lists the contents of the directory and specifies filenames -> blob relationship
* One commit with the pointer to the root tree and all the commit metadata. [SHOW IMAGE NOW]
                    </aside>
                </section>
                <section>
                    <h2>Add more commits</h2>
                    <p class="fragment"><img src="/images/GitIntro/branches-commits-chain.png" alt="" width="80%" /></p>
                    <aside class="notes" data-markdown>
So we make some changes and add a few more commits.
Each commit adds a pointer to the commit before it. After two commits your commit chain looks something like this
                    </aside>
                </section>
                <section>
                    <h2>The master branch</h2>
                    <p>
                        <img src="/images/GitIntro/branches-master-1.png" alt="" width="80%" />
                    </p>
                    <aside class="notes" data-markdown>
A branch in git is simply a lightweight movable pointer to one of these commits. The default branch name in Git is master. As you initially make commits, you’re given a master branch that points to the last commit you made. Every time you commit, it moves forward automatically.
                    </aside>
                </section>
                <section>
                    <h2>Create a new branch</h2>
                    <p>
                        <pre><code data-trim class="bash">
> git branch testing
</code></pre>
                    </p>
                    <p class="fragment">
                        <img src="/images/GitIntro/branches-add-new-branch.png" alt="" width="80%" />
                    </p>
                    <aside class="notes" data-markdown>
Adding a new branch simply creates a new pointer on the same commit you're currently on.
                    </aside>
                </section>
                <section>
                    <h2>The HEAD pointer</h2>
                    <p class="fragment">
                        <img src="/images/GitIntro/branches-head.png" alt="" width="80%" />
                    </p>
                    <aside class="notes" data-markdown>
How does git know which branch you're on?
HEAD is simply a pointer to your current branch and is how git keeps track of where you are.
In this case you're still on master. git branch only creates a new branch. It didn't switch to that branch.
                    </aside>
                </section>
                <section>
                    <h2>Switching branches</h2>
                    <p>
                        <pre><code data-trim class="bash">
> git checkout testing
</code></pre>
                    </p>
                    <p class="fragment">
                        <img src="/images/GitIntro/branches-head-testing.png" alt="" width="80%" />
                    </p>
                    <aside class="notes" data-markdown>In this case this simply moves HEAD to point to the testing branch.
                    </aside>
                </section>
                <section>
                    <h2>Let's add a commit</h2>
                    <p>
                        <pre><code data-trim class="bash">
> notepad test.rb
> git commit -a -m "made a change"
</code></pre>
                    </p>
                    <p class="fragment">
                        <img src="/images/GitIntro/branches-testing-commit.png" alt="" width="80%" />
                    </p>
                    <aside class="notes" data-markdown>
This is interesting because testing has moved forward but master still points to the previous commit.
Let's swich back to the master branch (next slide)
                    </aside>
                </section>
                <section>
                    <h2>Switch back to master</h2>
                    <p>
                        <pre><code class="bash" data-trim>
> git checkout master
</code></pre>
                    </p>
                    <p class="fragment">
                        <img src="/images/GitIntro/branches-back-to-master.png" alt="" width="80%" />
                    </p>
                    <aside class="notes" data-markdown>
Two things just happened:

* The HEAD pointer was moved back to point to the master branch
* Files in the working dir were reverted back to the snapshot that master points to.

Changes made from this point will diverge from an older version of the project.
Let's make a few more changes and commit again.
                    </aside>
                </section>
                <section>
                    <h2>A few more changes</h2>
                    <p>
                        <pre><code data-trim class="bash">
> notepad test.rb
> git commit -am "Made another change"
</code></pre>
                    </p>
                    <p class="fragment">
                        <img src="/images/GitIntro/branches-master-morecommits.png" alt="" width="80%" />
                    </p>
                    <aside class="notes" data-markdown>
* Project has now diverged
* Both changes are isolated in separate branches.
* All this is done with simple branch and checkout commands.
* A git branch is simply a 40-character text file. (41 bytes including newline - REALLY fast to create)

* Other VCS's typically copy all files to second directory. This takes TIME!
* Easy to find merge base since parents are recorded in history.
                    </aside>
                </section>
                <section>
                    <h2>All this happens on your local machine!</h2>
                    <p class="fragment">
                        Branches only appear on the server if you explicitly push them there. 
                    </p>
                    <aside class="notes" data-markdown>
I could have dozens or even hundreds of branches in my repo without anyone ever knowing about them. 
It's only if I explicitly choose to push my branches upstream that they become available to others. 
  
Note that branches all live _inside_ the repo. You won't see multiple copies of the codebase on your machine.
                    </aside>
                </section>                
            </section>
            <section>
                <section>
                    <h1>Part 4</h1>
                    <h2>Merging</h2>
                </section>
                <section>
                    <h1>Basic branching</h1>
                    <h3>(a quick recap)</h3>
                    <img class="fragment" src="images/GitIntro/basicbranching/basic-branching-1.png" width="80%" />
                    <aside class="notes" data-markdown>
Let's say you’re working on your project and have a couple of commits already.
                    </aside>
                </section>
                <section>
                    <h2>Let's work on an issue!</h2>
                    <p>
                        <pre><code data-trim class="bash">$ git checkout -b iss53
Switched to a new branch "iss53"</code></pre>
                    </p>
                    <img class="fragment" src="images/GitIntro/basicbranching/basic-branching-2.png" alt="" width="80%">
                    <aside class="notes" data-markdown>
You’ve decided that you’re going to work on issue #53 in whatever issue-tracking system your company uses. 
To create a branch and switch to it at the same time, you can run the git checkout command with the -b switch. HEAD now points at iss53.</aside>
                </section>
                <section>
                    <h1>Disaster strikes!</h1>
                    <h3>(not really, we've got a safety net)<h3>
                    <img class="fragment" src="images/GitIntro/basicbranching/basic-branching-3.png" alt="" width="80%">
                    <aside class="notes" data-markdown>
You've done some work and then you get a call about issue with live site. You don't have to worry about deploying the changes in iss53.
Simply switch back to your master branch.  
But first! Make sure you have a clean working directory!.
                    </aside>
                </section>
                <section>
                    <h2>Hotfix time!</h2>
                    <pre class="fragment"><code data-trim class="bash">
$ git checkout master
Switched to branch 'master'</code></pre>
                    <pre class="fragment"><code data-trim class="bash">
$ git checkout -b hotfix
Switched to a new branch 'hotfix'
$ notepad index.html

(... fix problem ...)

$ git commit -a -m 'Fix the broken email address'
[hotfix 1fb7853] fixed the broken email address
 1 file changed, 2 insertions(+)</code></pre>
                    <aside class="notes" data-markdown>
- First checkout master
- Working dir is now exactly the same  as before starting work on issue 53.  
- Git resets your working dir to look like it did the last time you committed on the branch.  
- Since we have to make a hotfix let's create a hotfix branch to work on.
                    </aside>
                </section>
                <section>
                    <h2>Hotfix branch based on master</h2>
                    <img src="images/GitIntro/basicbranching/basic-branching-4.png" alt="" width="80%">
                    <aside class="notes" data-markdown>
Now make sure your tests run and the hotfix is what we want and merge it back to master to deploy to production.  
You do this with the merge command.</aside>
                </section>
                <section>
                    <h2>Merge!</h2>
                    <pre><code data-trim class="bash">
$ git checkout master
$ git merge hotfix
Updating f42c576..3a0874c
Fast-forward
 index.html | 2 ++
 1 file changed, 2 insertions(+)
 </code></pre>
                    
                </section>
                <section>
                    <h2>The fast-forward merge</h2>
                    <img src="images/GitIntro/basicbranching/basic-branching-5.png" alt="" width="80%">
                    <aside class="notes" data-markdown>
* Explain fast-forward and moving pointers when base branch is a direct ancestor..
* Our change is now in the snapshot of the commit pointed to by the master branch and is ready to deploy.
                    </aside>
                </section>
                <section>
                    <h2>Now clean up and switch back</h2>
                    <pre class="fragment"><code data-trim class="bash">
$ git branch -d hotfix
Deleted branch hotfix (3a0874c).</code></pre>
                    <pre class="fragment"><code class="bash" data-trim>
$ git checkout iss53
Switched to branch "iss53"
$ vim index.html

( ... do stuff ...)

$ git commit -a -m 'finish the new footer [issue 53]'
[iss53 ad82d7a] finish the new footer [issue 53]
1 file changed, 1 insertion(+)
</code></pre>
                </section>
                <section>
                    <h2>Work continues on iss53</h2>
                    <img src="images/GitIntro/basicbranching/basic-branching-6.png" alt="" width="80%">
                    <aside class="notes" data-markdown>
It’s worth noting here that the work you did in your hotfix branch is not contained in the files in your iss53 branch. If you need to pull it in, you can merge your master branch into your iss53 branch by running git merge master, or you can wait to integrate those changes until you decide to pull the iss53 branch back into master later.
                    </aside>
                </section>
                <section>
                    <h1>Basic Merging</h1>
                    <pre><code class="bash" data-trim>
$ git checkout master
Switched to branch 'master'

$ git merge iss53
Merge made by the 'recursive' strategy.
index.html |    1 +
1 file changed, 1 insertion(+)
</code></pre>
                </section>
                <section>
                    <h2>Snapshots used in a typical merge</h2>
                    <img src="images/GitIntro/basicbranching/basic-merging-1.png" alt="" width="80%">
                    <aside class="notes" data-markdown>
Because work has diverged, Git has to do a three-way merge using the two snapshots pointed to by the branch tips and the common ancestor of the two.
                    </aside>

                </section>
                <section>
                    <h2>The merge commit</h2>
                    <img src="images/GitIntro/basicbranching/basic-merging-2.png" alt="" width="80%">
                    <aside class="notes" data-markdown>
Instead of just moving the branch pointer forward, Git creates a new snapshot that results from this three-way merge and automatically creates a new commit that points to it. This is referred to as a merge commit, and is special in that it has more than one parent.
                    </aside>
                </section>
                <section>
                    <h1>Branch management</h1>
                </section>
                <section>
                    <h1>List branches</h1>
                    <pre><code data-trim>$ git branch
  iss53
* master
  testing</code></pre>
                <aside class="notes" data-markdown>
git branch with no arguments gives a simple list of your current branches.  
Notice the * character that indicates the branch you currently have checked out (where HEAD points to)</aside>
                </section>
                <section>
                    <h1>List branches</h1>
                    <h4>(verbose)</h4>
                    <pre><code class="bash" data-trim>$ git branch -v
  iss53   93b412c fix javascript issue
* master  7a98805 Merge branch 'iss53'
  testing 782fd34 add scott to the author list in the readmes</code></pre>
                    <aside class="notes" data-markdown>
The -v switch shows the last commit on each branch.
                    </aside>
                </section>
                <section>
                    <h2>Is my branch merged?</h2>
                    <pre class="fragment"><code class="bash" data-trim>$ git branch --merged
  iss53
* master</code>Lists branches that have been integrated into your current branch.</pre>
                    <pre class="fragment"><code class="bash" data-trim>$ git branch --no-merged
  testing</code>Lists branches that have <em>not yet</em> been integrated into your current branch.</pre>
                    <aside class="notes" data-markdown>
--merged and --no-merged options can filter this list to branches that you have or have not yet merged into the branch you’re currently on.
                    </aside>
                </section>
            </section>
            <section>
                <section>
                    <h1>Part 5</h1>
                    <h2>Rebasing</h2>
                    <aside class="notes" data-markdown>
                        In Git, there are two main ways to integrate changes from one branch into another: the merge and the rebase. 
                        In this section you’ll learn what rebasing is, how to do it, why it’s a pretty amazing tool, and in what cases you won’t want to use it.
                    </aside>
                </section>
                <section>
                    <h2>The basic rebase</h2>
                    <aside class="notes">
                        Quick walk-through of the most basic rebase, using the example from before. 
                    </aside>
                </section>
                <section>
                    <h2>Our current status</h2>
                    <img src="images/GitIntro/rebasing/basic-rebase-1.png" />
                    <aside class="notes" data-markdown>
                    If we look at our merge example, we remember that we diverged our work and made commits on two different branches.  
                    Easiest way to integrate = merge.  
                    What if we could simply apply our change on top of master?
                    </aside>
                </section>
                <section>
                    <pre><code class="bash" data-trim>
$ git checkout experiment
$ git rebase master
First, rewinding head to replay your work on top of it...
Applying: added staged command
</code></pre>
                    <p class="fragment">
                        <img src="images/GitIntro/rebasing/basic-rebase-3.png" />
                    </p>

                <aside class="notes">
                    You can apply the <em>patch</em> of the change C4 and reapply it on top of C3<br />
                    It works by going to the common ancestor of the two branches (the one you’re on and the one you’re rebasing onto), getting the diff introduced by each commit of the branch you’re on, saving those diffs to temporary files, resetting the current branch to the same commit as the branch you are rebasing onto, and finally applying each change in turn.s
                    </aside>
                </section>
                <section>
                    <h2>Now you can just fast-forward master</h2>
                    <pre><code class="bash" data-trim>
$ git checkout master
$ git merge experiment</code></pre>
                    <img src="images/GitIntro/rebasing/basic-rebase-4.png" class="fragment" />
                    <p class="fragment">See how neat our history looks now?</p>
                </section>
                <section>
                    <h2>A more interesting example</h2>
                    <img src="images/GitIntro/rebasing/interesting-rebase-1.png" />
                    <aside class="notes">You branched a topic branch (server) to add some server-side functionality to your project, and made a commit. Then, you branched off that to make the client-side changes (client) and committed a few times. Finally, you went back to your server branch and did a few more commits.</aside>
                </section>
                <section>
                    <h2>Prepare client-side for release</h2>
                    <pre><code class="bash" data-trim>$ git rebase --onto master server client</code></pre>
                    <img src="images/GitIntro/rebasing/interesting-rebase-2.png" class="fragment"/>
                    <aside class="notes">You can take the changes on client that aren’t on server (C8 and C9) and replay them on your master branch by using the --onto option of git rebase.
                    This basically says, “Check out the client branch, figure out the patches from the common ancestor of the client and server branches, and then replay them onto master.” It’s a bit complex, but the result is pretty cool.</aside>
                </section>
                <section>
                    <h2>Fast-forward master</h2>
                    <pre><code class="bash" data-trim>
$ git checkout master
$ git merge client</code></pre>
                    <img src="images/GitIntro/rebasing/interesting-rebase-3.png" />
                </section>
                <section>
                    <h2>Now to integrate the 'server' branch</h2>
                    <pre><code class="bash" data-trim>$ git rebase master server</code></pre>
                    <img class="fragment" src="images/GitIntro/rebasing/interesting-rebase-4.png" />
                    <aside class="notes">Let’s say you decide to pull in your server branch as well. You can rebase the server branch onto the master branch without having to check it out first by running git rebase [basebranch] [topicbranch] – which checks out the topic branch (in this case, server) for you and replays it onto the base branch (master):
                </section>
                <section>
                    <h2>Clean-up time</h2>
                    <p>First, fast-forward as usual</p>
                    <pre class="fragment"><code class="bash" data-trim>
$ git checkout master
$ git merge server</code></pre>
                    <p class="fragment">Then delete your topic branches</p>
                    <pre class="fragment"><code class="bash" data-trim>
$ git branch -d client
$ git branch -d server</code></pre>
                <aside class="notes">All the work is integrated so we don't need the topic branches anymore.</aside>
                </section>
                <section>
                    <h2>Final commit history</h2>
                    <img src="images/GitIntro/rebasing/interesting-rebase-5.png" >
                    <p>Neat and tidy, right?</p>
                </section>
                <section>
                    <h2>The perils of Rebasing</h2>
                </section>
                <section>
                    <h2>Never rebase commits that exist outside your repo!</h2>
                    <aside class="notes">Rebasing abandons existing commits and creates new ones that are similar but different.
                    If you push commits and others pull them down to work on them and then you rewrite them with git rebase and push them up again, your collaborators will have to re-merge, making things messy.</aside>
                </section>
                <section>
                    <h2>An example of rebase hell</h2>
                    <img src="images/GitIntro/rebasing/perils-of-rebasing-1.png" width="70%" />
                    <p>You clone a remote repo and do some work on that</p>
                    <aside class="notes">Let’s look at an example of how rebasing work that you’ve made public can cause problems. Suppose you clone from a central server and then do some work off that. Your commit history looks like this</aside>
                </section>
                <section>
                    <h2>Your teammate keeps working and pushing code</h2>
                    <img src="images/GitIntro/rebasing/perils-of-rebasing-2.png" width="70%" />
                    <p>He pushes some commits that include a merge</p>
                    <aside class="notes">Now, someone else does more work that includes a merge, and pushes that work to the central server. You fetch it and merge the new remote branch into your work, making your history look something like this</aside>
                </section>
                <section>
                    <h3>Teammate decides to rebase instead</h3>
                    <p> - and does a git push --force to overwrite history on the server</p>
                    <img src="images/GitIntro/rebasing/perils-of-rebasing-3.png" width="70%"/>
                    <aside class="notes">You then fetch from that server, bringing down the new commits. Your history now looks like this.</aside>
                </section>
                <section>
                    <h3>If you pull now, you're in a pickle</h3>
                    <img src="images/GitIntro/rebasing/perils-of-rebasing-4.png" width="70%"/>
                    <aside class="notes">Now you’re both in a pickle. If you do a git pull, you’ll create a merge commit which includes both lines of history, and your repository will look like this. 
                    Git log will show you two commits with the same author, date and message which is confusing. If you push now you'll push all these commits up, increasing confusion.
                    </aside>
                </section>
                <section>
                    <h2>The solution/fix to this problem</h2>
                    <p>git pull --rebase</p>
                    <p>Rebases your local changes onto remote changes</p>
                </section>
                <section>
                    <h2>So instead of this</h2>
                    <img src="images/GitIntro/rebasing/perils-of-rebasing-4.png" width="70%"/>
                </section>
                <section>
                    <h2>We get this</h2>
                    <img src="images/GitIntro/rebasing/perils-of-rebasing-5.png" width="70%"/>
                    <aside class="notes">It turns out that in addition to the commit SHA-1 checksum, Git also calculates a checksum that is based just on the patch introduced with the commit. This is called a “patch-id”.<br /><br />

If you pull down work that was rewritten and rebase it on top of the new commits from your partner, Git can often successfully figure out what is uniquely yours and apply them back on top of the new branch.</aside>
                </section>
            </section>
            <section>
                <section>
                    <h1>Part 6</h1>
                    <h2>Git workflows</h2>
                </section>
                <section>
                    <h2>Centralized Workflow</h2>
                    <img src="/images/GitIntro/workflow_centralized.png" alt="" width="80%" />
                    <aside class="notes" data-markdown>
* Essentially the same model as with any CVCS like TFVC or SVN
* First-to-push wins. Following have to merge.
* Still have the benifit of working locally!
                    </aside>
                </section>

                <section>
                    <h2>Integration-Manager Workflow</h2>
                    <img src="/images/GitIntro/workflow_integrationmanager.png" alt="" width="80%" />
                    <aside class="notes">
                        This is basically how the Pull Request workflow in GitHub works.
                        <ol>
                            <li>The project maintainer pushes to their public repository.</li>
                            <li>A contributor forks that repository, clones it and makes changes.</li>
                            <li>The contributor pushes to their own public copy or "fork"</li>
                            <li>The contributor sends the maintainer an e-mail asking them to pull changes
                            (or presses the Pull Request button)</li>
                            <li>The maintainer adds the contributor’s repo as a remote and merges locally.
                            (Or does the merge through Github)</li>
                            <li>The maintainer pushes merged changes to the main repository.
                            (Or lets Github do the magic)</li>
                        </ol>
                    </aside>
                </section>

                <section>
                    <h2>Dictator and Lieutenants Workflow</h2>
                    <img src="/images/GitIntro/workflow_dictatorAndLieutenants.png" alt="" width="80%" />
                    <aside class="notes">
                        This is a variant of a multiple-repository workflow. It’s generally used by huge projects with hundreds of collaborators; one famous example is the Linux kernel.
                        <ol>
                            <li>Regular developers work on their topic branch and rebase their work on top of master. The master branch is that of the dictator.</li>
                            <li>Lieutenants merge the developers’ topic branches into their master branch.</li>
                            <li>The dictator merges the lieutenants’ master branches into the dictator’s master branch.</li>
                            <li>The dictator pushes their master to the reference repository so the other developers can rebase on it.</li>
                        </ol>
                    </aside>
                </section>
            </section>

            <section>
                <section>
                    <h1>Part 5</h1>
                    <h2>Git in VS & TFS</h2>
                </section>

                <section>
                    <h2>Tooling Support</h2>
                    <ul>
                        <li class="fragment">VS has supported git natively since VS 2012 update 2</li>
                        <li class="fragment">TFS supports git repos on the server since TFS 2013</li>
                        <li class="fragment">TFS supports repo-local pull requests quite well!</li>
                        <li class="fragment">Pretty good integration with work items etc.</li>
                    </ul>
                    <aside class="notes" data-markdown>
* Visual Studio has a built-in Git client but I personally don't like it a lot. It tries to hide too many central concepts, making Git seem "magical" to the user. 

* Rumors have it that Microsoft is considering switching to git completely as the default TFS source control.
                    </aside>
                </section>

                <section>
                    <h2>TFVC vs Git VC</h2>
                    <aside class="notes" data-markdown>
* You need to look at the strengths and features of each VCS.
* Also take into account the experiences and preferences of team members
* Choice simply comes down to which VCS to use
* (because git is fully integrated in TFS)
                    </aside>
                </section>

                <section>
                    <h2>Team Foundation Server Version Control</h2>
                    <h3>(TFSVC)</h3>
                    <aside class="notes">
                        <ul>
                            <li>Centralized version control system</li>
                            <li>Works well for small codebases</li>
                            <li>Scalable for very large codebases (together with the server workspace)</li>
                            <li>Provides granular permission control</li>
                            <li>
                                <div>Because of the centralized character:</div>
                                <ul>
                                    <li>It is easy to audit changes</li>
                                    <li>It is easy to identify who changed the code/files</li>
                                </ul>
                            </li>
                        </ul>
                    </aside>
                </section>

                <section>
                    <h2>Git Version Control</h2>
                    <h3>(Git VC)</h3>
                    <aside class="notes">
                        <ul>
                            <li>Distributed version control system</li>
                            <li>Each developer has a copy of the entire source repository, on their local disk, implicating that developers can work, even when connectivity is an issue.</li>
                            <li>
                                <div>Branching is very lightweight:</div>
                                <ul>
                                    <li>Create local and private branches</li>
                                    <li>Context switching made easy</li>
                                    <li>Branch only available for all team members, after being pushed to the server.</li>
                                </ul>
                            </li>
                            <li>Local repository is version control enabled</li>
                            <li>You can have modular codebases distributed across multiple repositories</li>
                        </ul>
                    </aside>
                </section>
            <section>
                <h1>Discussion time!</h1>
            </section>
            <section>
                <h1>THE END</h1>
            </section>
        </div>
		</div>

		<script src="lib/js/head.min.js"></script>
		<script src="js/reveal.js"></script>

		<script>

			// Full list of configuration options available at:
			// https://github.com/hakimel/reveal.js#configuration
			Reveal.initialize({
				controls: true,
				progress: true,
				history: true,
                keyboard: true,
				center: true,

				transition: 'slide', // none/fade/slide/convex/concave/zoom

                multiplex: {
                    secret: null,
                    id: '9e2066bdbfc85901',
                    url: 'https://socketio.azurewebsites.net'
                },
				//Optional reveal.js plugins
				dependencies: [
                    { src: 'https://cdn.socket.io/socket.io-1.3.5.js', async: true },
                    //{ src: 'plugin/multiplex/client.js', async: true },
                    { src: 'plugin/notes/notes.js', async: true },
					{ src: 'lib/js/classList.js', condition: function() { return !document.body.classList; } },
					{ src: 'plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
					{ src: 'plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
					{ src: 'plugin/highlight/highlight.js', async: true, condition: function() { return !!document.querySelector( 'pre code' ); }, callback: function() { hljs.initHighlightingOnLoad(); } },
					{ src: 'plugin/zoom-js/zoom.js', async: true },
					{ src: 'plugin/notes/notes.js', async: true }
				]
			});

		</script>

	</body>
</html>
